from __future__ import annotations

from pathlib import Path

from archsync.config import RulesConfig
from archsync.schemas import ArchitectureEdge, ArchitectureModel, ModuleNode
from archsync.utils import write_json


def _clip(value: str, max_len: int) -> str:
    if len(value) <= max_len:
        return value
    return f"{value[: max_len - 1]}â€¦"


def _ancestor(module_id: str, target_level: int, lookup: dict[str, ModuleNode]) -> ModuleNode | None:
    current = lookup.get(module_id)
    while current is not None:
        if current.level == target_level:
            return current
        if not current.parent_id:
            return None
        current = lookup.get(current.parent_id)
    return None


def _collect_views(model: ArchitectureModel) -> dict[str, tuple[list[ModuleNode], list[ArchitectureEdge]]]:
    lookup = {item.id: item for item in model.modules}
    levels = sorted({item.level for item in model.modules if item.level >= 1})
    if not levels:
        return {}

    views: dict[str, tuple[list[ModuleNode], list[ArchitectureEdge]]] = {}

    for target_level in levels:
        key = f"l{target_level - 1}"
        nodes = [item for item in model.modules if item.level == target_level]
        visible = {item.id for item in nodes}

        edges_map: dict[tuple[str, str, str, str], ArchitectureEdge] = {}
        for edge in model.edges:
            src = _ancestor(edge.src_id, target_level, lookup)
            dst = _ancestor(edge.dst_id, target_level, lookup)
            if not src or not dst:
                continue
            if src.id == dst.id:
                continue
            if src.id not in visible or dst.id not in visible:
                continue

            edge_key = (src.id, dst.id, edge.kind, edge.label)
            if edge_key in edges_map:
                continue

            edges_map[edge_key] = ArchitectureEdge(
                id=f"{key}:{src.id}:{dst.id}:{edge.kind}",
                src_id=src.id,
                dst_id=dst.id,
                kind=edge.kind,
                label=edge.label,
                evidence_ids=[],
            )

        edges = sorted(
            edges_map.values(),
            key=lambda item: (item.kind, item.src_id, item.dst_id, item.label),
        )
        views[key] = (nodes, edges)

    return views


def _node_alias(node_id: str) -> str:
    return node_id.replace(":", "_").replace("-", "_").replace("/", "_").replace(".", "_")


def _mermaid_for_view(
    view_name: str,
    nodes: list[ModuleNode],
    edges: list[ArchitectureEdge],
) -> str:
    lines = [f"%% ArchSync {view_name}", "flowchart LR"]

    for node in sorted(nodes, key=lambda item: (item.level, item.layer, item.name)):
        lines.append(f'  {_node_alias(node.id)}["{node.name}"]')

    for edge in edges:
        src = _node_alias(edge.src_id)
        dst = _node_alias(edge.dst_id)
        lines.append(f'  {src} -->|{_clip(edge.label, 30)}| {dst}')

    return "\n".join(lines) + "\n"


def _dot_graph(model: ArchitectureModel) -> str:
    lines = ["digraph ArchSync {", '  rankdir="LR";', '  node [shape="box" style="rounded"];']
    for module in sorted(model.modules, key=lambda item: (item.level, item.layer, item.path)):
        if module.level < 1:
            continue
        lines.append(
            f'  "{module.id}" [label="{module.name}\\n{module.layer} L{module.level}"];'
        )

    for edge in sorted(model.edges, key=lambda item: (item.kind, item.src_id, item.dst_id, item.label)):
        lines.append(f'  "{edge.src_id}" -> "{edge.dst_id}" [label="{_clip(edge.label, 32)}"];')

    lines.append("}")
    return "\n".join(lines) + "\n"


def _structurizr_dsl(model: ArchitectureModel, rules: RulesConfig) -> str:
    lines: list[str] = []
    lines.append(f'workspace "{rules.system_name}" "Generated by ArchSync" {{')
    lines.append("  model {")
    lines.append("    softwareSystem sys \"System\" {")

    level1 = [item for item in model.modules if item.level == 1]
    level2 = [item for item in model.modules if item.level == 2]

    for layer in sorted(level1, key=lambda item: item.name):
        lines.append(f'      container "{layer.name}" "{layer.path}" "Layer"')

    for module in sorted(level2, key=lambda item: (item.layer, item.name)):
        lines.append(f'      component "{module.name}" "{module.path}" "Module"')

    lines.append("    }")
    lines.append("  }")
    lines.append("  views {")
    lines.append("    systemContext sys \"Context\" { include * autoLayout lr }")
    lines.append("    container sys \"Containers\" { include * autoLayout lr }")
    lines.append("    component sys \"Components\" { include * autoLayout lr }")
    lines.append("    theme default")
    lines.append("  }")
    lines.append("}")

    return "\n".join(lines) + "\n"


def render_outputs(
    model: ArchitectureModel,
    rules: RulesConfig,
    output_dir: Path,
    full: bool = False,
    only_views: set[str] | None = None,
) -> dict[str, Path]:
    output_dir.mkdir(parents=True, exist_ok=True)

    model_json = output_dir / "architecture.model.json"
    write_json(model_json, model.to_dict())

    outputs: dict[str, Path] = {
        "model_json": model_json,
    }

    if not full:
        return outputs

    views_input = _collect_views(model)
    target_views = set(only_views) if only_views else set(views_input.keys())

    mermaid_dir = output_dir / "mermaid"
    mermaid_dir.mkdir(parents=True, exist_ok=True)

    for key, (nodes, edges) in views_input.items():
        path = mermaid_dir / f"{key}.mmd"
        if key in target_views or not path.exists():
            path.write_text(_mermaid_for_view(key, nodes, edges), encoding="utf-8")
        outputs[f"{key}_mermaid"] = path

    dot_path = output_dir / "architecture.dot"
    dot_path.write_text(_dot_graph(model), encoding="utf-8")
    outputs["dot"] = dot_path

    dsl_path = output_dir / "workspace.dsl"
    dsl_path.write_text(_structurizr_dsl(model, rules), encoding="utf-8")
    outputs["structurizr_dsl"] = dsl_path

    return outputs
